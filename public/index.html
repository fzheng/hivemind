<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyperliquid BTC Perp Tracker</title>
    <meta name="theme-color" content="#0f1218" />
    <link rel="preload" href="/styles.css" as="style" />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <div class="wrap">
      <header class="site-header">
        <h1>Hyperliquid BTC Perp Tracker</h1>
        <div class="row" style="align-items:center; gap:12px;">
          <div class="small muted">BTC: <span id="btcPrice">-</span></div>
          <div class="small muted">IP: <a href="#" id="ipInfoLink" aria-label="Refresh IP and region">-</a></div>
        </div>
      </header>

      <div class="card" aria-labelledby="addressEntryTitle">
        <div class="row" style="align-items:flex-start;">
          <div style="display:flex; flex-direction:column; gap:6px;">
            <label class="small muted" id="addressEntryTitle" for="addrInput">Add a Hyperliquid address</label>
            <div class="row">
              <input id="addrInput" type="text" placeholder="0x..." autocomplete="off" inputmode="text" aria-label="Hyperliquid address" />
              <button id="addBtn" aria-label="Add address to tracking list">Add address</button>
            </div>
            <span id="addMsg" class="muted small" role="status" aria-live="polite"></span>
          </div>
        </div>
      </div>

      <div class="card" aria-labelledby="positionsTitle">
        <h3 id="positionsTitle" style="margin:0 0 8px">Current Positions (BTC)</h3>
        <table style="width:100%;">
          <thead>
            <tr>
              <th class="sortable" data-sort="address">Address</th>
              <th class="sortable" data-sort="side">Side</th>
              <th class="sortable" data-sort="size">Size</th>
              <th class="sortable" data-sort="entry">Entry</th>
              <th class="sortable" data-sort="lev">Lev</th>
              <th class="sortable" data-sort="liq">Liq</th>
              <th class="sortable" data-sort="pnl">PnL</th>
              <th class="sortable" data-sort="updated">Updated</th>
            </tr>
          </thead>
          <tbody id="positionsTbody"></tbody>
        </table>
      </div>

      <div class="card" aria-labelledby="tradesTitle">
        <div class="flex space-between mb-2" style="align-items:center; gap:8px;">
          <h3 id="tradesTitle" style="margin:0">Latest Trades (BTC)</h3>
          <div class="row">
            <label class="small muted" for="addrFilter">Address</label>
            <select id="addrFilter">
              <option value="">All</option>
            </select>
            <label class="small muted" for="timeModeSel">Time</label>
            <select id="timeModeSel">
              <option value="absolute">Absolute</option>
              <option value="relative" selected>Relative</option>
            </select>
            <button id="refreshTradesBtn" aria-label="Refresh latest trades">Refresh</button>
            <button id="loadMoreBtn" aria-label="Load older trades">Load more</button>
            <button id="backfillBtn" aria-label="Backfill trades">Backfill</button>
          </div>
        </div>
        <table style="width:100%;">
          <thead>
            <tr>
              <th class="sortable" data-sort="time">Time</th>
              <th class="sortable" data-sort="taddr">Address</th>
              <th class="sortable" data-sort="action">Action</th>
              <th class="sortable" data-sort="tsize">Size</th>
              <th class="sortable" data-sort="start">Start Position</th>
              <th class="sortable" data-sort="price">Price</th>
              <th class="sortable" data-sort="cpnl">Closed PnL</th>
            </tr>
          </thead>
          <tbody id="tradesTbody"></tbody>
        </table>
      </div>
    </div>

    <script>
      const addrInput = document.getElementById('addrInput');
      const addBtn = document.getElementById('addBtn');
      const addMsg = document.getElementById('addMsg');
      const positionsTbody = document.getElementById('positionsTbody');
      const tradesTbody = document.getElementById('tradesTbody');
      const refreshTradesBtn = document.getElementById('refreshTradesBtn');
      const loadMoreBtn = document.getElementById('loadMoreBtn');
      const backfillBtn = document.getElementById('backfillBtn');
      const addrFilterSel = document.getElementById('addrFilter');
      const timeModeSel = document.getElementById('timeModeSel');
      const btcPriceSpan = document.getElementById('btcPrice');
      const ipInfoLink = document.getElementById('ipInfoLink');
      let posSort = { key: 'updated', dir: 'desc' };
      let tradeSort = { key: 'time', dir: 'desc' };
      let tradesState = { items: [], nextBeforeId: null };
      let selectedAddress = '';
      let nickMap = {};
      let timeMode = 'relative';

      async function fetchPositions() {
        const r = await fetch('/api/current-positions');
        return (await r.json()).positions || [];
      }

      async function fetchLatestTrades(limit = 50) {
        const r = await fetch(`/api/latest-trades?limit=${limit}`);
        return (await r.json()).trades || [];
      }

      async function fetchPrice() {
        const r = await fetch('/api/price');
        return await r.json();
      }

      function renderPositions(positions) {
        positions = sortPositions(positions);
        positionsTbody.innerHTML = '';
        positions.forEach(p => {
          const tr = document.createElement('tr');
          const sideTxt = p.side === 'long' ? '<span class="tag long">Long</span>' : (p.side === 'short' ? '<span class="tag short">Short</span>' : 'Flat');
          const sizeTxt = Math.abs(Number(p.size || 0)).toFixed(4);
          const entryTxt = p.entryPriceUsd ? formatUsd(Number(p.entryPriceUsd)) : '-';
          const levTxt = p.leverage ? (Number(p.leverage).toFixed(1) + 'x') : '-';
          const liqTxt = p.liquidationPriceUsd ? formatUsd(Number(p.liquidationPriceUsd)) : '-';
          const pnlNum = (typeof p.pnlUsd === 'number' && isFinite(p.pnlUsd)) ? p.pnlUsd : null;
          const pnlTxt = pnlNum !== null ? formatUsd(pnlNum) : '-';
          const pnlClass = pnlNum !== null ? (pnlNum >= 0 ? 'score positive' : 'score negative') : '';
          const displayName = p.nickname ? `<strong>${escapeHtml(p.nickname)}</strong><div class="small muted">${p.address}</div>` : `<span class="addr">${p.address}</span>`;
          tr.innerHTML = `
            <td>
              <a href="#" class="addr" data-address="${p.address}">${displayName}</a>
              <div class="small">
                <a href="#" data-action="edit-nick" data-address="${p.address}" data-nick="${p.nickname || ''}">Nickname</a>
                <span class="muted"> · </span>
                <a href="#" data-action="remove" data-address="${p.address}">Remove</a>
              </div>
            </td>
            <td>${sideTxt}</td>
            <td>${sizeTxt}</td>
            <td>${entryTxt}</td>
            <td>${levTxt}</td>
            <td>${liqTxt}</td>
            <td class="${pnlClass}">${pnlTxt}</td>
            <td class="small muted">${formatTime(p.updatedAt)}</td>
          `;
          tr.querySelector('a[data-address]')?.addEventListener('click', (e) => { e.preventDefault(); showHoldings(p.address); });
          tr.querySelector('a[data-action="remove"]')?.addEventListener('click', async (e) => { e.preventDefault(); await removeAddress(p.address); await refresh(); });
          tr.querySelector('a[data-action="edit-nick"]')?.addEventListener('click', async (e) => { e.preventDefault(); await editNickname(p.address, p.nickname || ''); await refresh(); });
          // Add external Hyperbot link in actions
          (function(){ return;
            const actions = tr.querySelector('td .small');
            if (!actions) return;
            const sep = document.createElement('span');
            sep.className = 'muted';
            sep.textContent = ' · ';
            const link = document.createElement('a');
            link.href = `https://hyperbot.network/trader/${encodeURIComponent(p.address)}`;
            link.target = '_blank';
            link.rel = 'noopener';
            link.textContent = 'Hyperbot ↗';
            actions.appendChild(sep);
            actions.appendChild(link);
          })();
          positionsTbody.appendChild(tr);
        });
      }

      function renderTrades(trades, { append } = { append: false }) {
        trades = sortTrades(trades);
        if (!append) tradesTbody.innerHTML = '';
        trades.forEach(t => {
          const tr = document.createElement('tr');
          const pnl = (typeof t.closedPnl === 'number' && isFinite(t.closedPnl)) ? t.closedPnl : null;
          const pnlTxt = pnl !== null ? formatUsd(pnl) : '-';
          const pnlClass = pnl !== null ? (pnl >= 0 ? 'score positive' : 'score negative') : '';
          const nick = nickMap && nickMap[t.address] ? String(nickMap[t.address]) : '';
          const addrHtml = nick ? (`<strong>${escapeHtml(nick)}</strong><div class="small muted">${t.address}</div>`) : `<span class="addr">${t.address}</span>`;
          tr.innerHTML = `
            <td class="small muted">${formatTime(t.time)}</td>
            <td>${addrHtml}</td>
            <td>${escapeHtml(t.action || '')}</td>
            <td>${Number(t.size).toFixed(5)}</td>
            <td>${Number(t.startPosition ?? 0).toFixed(5)}</td>
            <td>${formatUsd(Number(t.price))}</td>
            <td class="${pnlClass}">${pnlTxt}</td>
          `;
          tradesTbody.appendChild(tr);
        });
      }

      function sortPositions(positions) {
        const k = posSort.key, d = posSort.dir === 'asc' ? 1 : -1;
        const get = {
          address: p => p.address,
          side: p => ({ long: 1, short: -1, flat: 0 })[p.side] || 0,
          size: p => Number(p.size) || 0,
          entry: p => Number(p.entryPriceUsd) || -Infinity,
          lev: p => Number(p.leverage) || 0,
          liq: p => Number(p.liquidationPriceUsd) || -Infinity,
          pnl: p => Number(p.pnlUsd) || -Infinity,
          updated: p => new Date(p.updatedAt).getTime(),
        }[k] || ((p)=>0);
        return positions.slice().sort((a,b)=>{
          const av = get(a), bv = get(b);
          if (av < bv) return -1*d; if (av > bv) return 1*d; return 0;
        });
      }
      function sortTrades(trades) {
        const k = tradeSort.key, d = tradeSort.dir === 'asc' ? 1 : -1;
        const get = {
          time: t => new Date(t.time).getTime(),
          taddr: t => t.address,
          action: t => t.action,
          tsize: t => Number(t.size) || 0,
          start: t => Number(t.startPosition) || 0,
          price: t => Number(t.price) || 0,
          cpnl: t => Number(t.closedPnl) || 0,
        }[k] || ((t)=>0);
        return trades.slice().sort((a,b)=>{
          const av = get(a), bv = get(b);
          if (av < bv) return -1*d; if (av > bv) return 1*d; return 0;
        });
      }

      async function refresh() {
        try {
          const positions = await fetchPositions();
          renderPositions(positions);
        } catch (e) {
          console.error('refresh failed', e);
        }
      }

      async function refreshPrice() {
        try {
          const p = await fetchPrice();
          const price = p && typeof p.price === 'number' ? p.price : null;
          if (price && isFinite(price)) {
            btcPriceSpan.textContent = formatUsd(Number(price));
          }
        } catch (e) {}
      }

      async function refreshIpDisplay() {
        try {
          const r = await fetch('/api/ipinfo');
          const j = await r.json();
          const ip = j && typeof j.ip === 'string' ? j.ip : '-';
          const region = j && typeof j.region === 'string' ? j.region : null;
          const country = j && typeof j.country === 'string' ? j.country : null;
          const city = j && typeof j.city === 'string' ? j.city : null;
          let suffix = '';
          if (city && country) suffix = `${city}, ${country}`;
          else if (country) suffix = country;
          else if (region) suffix = region;
          ipInfoLink.textContent = suffix ? `${ip} (${suffix})` : ip;
          ipInfoLink.title = 'Click to refresh IP via server';
        } catch (e) {
          ipInfoLink.textContent = '-';
        }
      }

      addBtn.addEventListener('click', async () => {
        const address = (addrInput.value || '').trim();
        addMsg.textContent = '';
        if (!address) return;
        try {
          const r = await fetch('/api/addresses', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ address })
          });
          if (!r.ok) {
            const j = await r.json().catch(() => ({}));
            addMsg.textContent = j.error || 'Failed to add address';
            return;
          }
          addrInput.value = '';
          addMsg.textContent = 'Added';
          setTimeout(() => (addMsg.textContent = ''), 1200);
          await refresh();
        } catch (e) {
          addMsg.textContent = 'Network error';
        }
      });

      // IP refresh click (server-originated call)
      if (ipInfoLink) {
        ipInfoLink.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            ipInfoLink.textContent = '…';
            await fetch('/api/ipinfo/refresh', { method: 'POST' });
          } catch (e) { /* ignore */ }
          await refreshIpDisplay();
        });
      }

      async function removeAddress(address) {
        await fetch(`/api/addresses/${encodeURIComponent(address)}`, { method: 'DELETE' });
      }

      async function editNickname(address, currentNick) {
        const next = prompt('Set nickname for address', currentNick || '');
        if (next === null) return; // cancelled
        await fetch(`/api/addresses/${encodeURIComponent(address)}/nickname`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ nickname: next })
        });
      }

      // Modal for holdings (per address)
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      const modalCard = document.createElement('div');
      modalCard.className = 'modal-card';
      modalCard.innerHTML = '<div class="row" style="justify-content:space-between; align-items:center; margin-bottom:8px;"><div id="modalHeader" class="row" style="gap:8px; align-items:center;"><strong>Perp holdings</strong><a id="modalHyperbot" href="#" target="_blank" rel="noopener" class="small" style="text-decoration:underline;">Open in Hyperbot ↗</a></div><button id="modalClose" aria-label="Close holdings modal">Close</button></div><div id="modalBody" class="small"></div>';
      modal.appendChild(modalCard);
      document.body.appendChild(modal);
      document.getElementById('modalClose').addEventListener('click', () => { modal.style.display = 'none'; });

      async function showHoldings(address) {
        modal.style.display = 'flex';
        const hbLink = modal.querySelector('#modalHyperbot');
        if (hbLink) hbLink.setAttribute('href', 'https://hyperbot.network/trader/' + encodeURIComponent(address));
        const body = modal.querySelector('#modalBody');
        body.textContent = 'Loading...';
        try {
          const r = await fetch(`/api/positions/${encodeURIComponent(address)}`);
          const j = await r.json();
          const positions = j.positions || [];
          if (!positions.length) {
            body.textContent = 'No open perp positions.';
            return;
          }
          const tbl = document.createElement('table');
          tbl.style.width = '100%';
          tbl.style.borderCollapse = 'collapse';
          tbl.innerHTML = '<thead><tr><th>Symbol</th><th>Side</th><th>Size</th><th>Entry</th><th>Lev</th></tr></thead>';
          const tb = document.createElement('tbody');
          positions.forEach(p => {
            const tr = document.createElement('tr');
            const side = p.size > 0 ? 'Long' : 'Short';
            tr.innerHTML = `
              <td>${p.symbol}</td>
              <td>${side}</td>
              <td>${Math.abs(p.size).toFixed(4)}</td>
              <td>${p.entryPriceUsd ? formatUsd(Number(p.entryPriceUsd)) : '-'}</td>
              <td>${p.leverage ? Number(p.leverage).toFixed(1) + 'x' : '-'}</td>
            `;
            Array.from(tr.children).forEach(td => td.style.padding = '6px');
            tb.appendChild(tr);
          });
          tbl.appendChild(tb);
          body.innerHTML = '';
          body.appendChild(tbl);
        } catch (e) {
          body.textContent = 'Failed to load holdings.';
        }
      }

      // Sorting handlers
      document.querySelectorAll('#positionsTitle ~ table thead th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          if (posSort.key === key) posSort.dir = posSort.dir === 'asc' ? 'desc' : 'asc';
          else { posSort.key = key; posSort.dir = 'desc'; }
          fetchPositions().then(renderPositions).catch(()=>{});
        });
      });
      document.querySelectorAll('#tradesTitle ~ table thead th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          if (tradeSort.key === key) tradeSort.dir = tradeSort.dir === 'asc' ? 'desc' : 'asc';
          else { tradeSort.key = key; tradeSort.dir = 'desc'; }
          renderTrades(tradesState.items);
        });
      });

      // Initial load and polling
      refresh();
      setInterval(refresh, 5000);
      refreshPrice();
      setInterval(refreshPrice, 3000);
      // Initial IP info + periodic UI refresh (server fetch interval is independent)
      refreshIpDisplay();
      setInterval(refreshIpDisplay, 60000);
      async function loadTradesPage({ reset } = { reset: false }) {
        try {
          const params = new URLSearchParams();
          params.set('limit', '100');
          if (!reset && tradesState.nextBeforeId) params.set('beforeId', String(tradesState.nextBeforeId));
          if (selectedAddress) params.set('address', selectedAddress);
          const r = await fetch('/api/latest-trades?'+params.toString());
          const j = await r.json();
          const items = j.trades || [];
          const nextBeforeId = j.nextBeforeId || null;
          if (reset) {
            tradesState.items = items;
            tradesState.nextBeforeId = nextBeforeId;
            renderTrades(tradesState.items);
          } else {
            tradesState.items = (tradesState.items || []).concat(items);
            tradesState.nextBeforeId = nextBeforeId;
            renderTrades(items, { append: true });
          }
          loadMoreBtn.disabled = !tradesState.nextBeforeId;
        } catch (e) { /* ignore */ }
      }

      refreshTradesBtn.addEventListener('click', () => loadTradesPage({ reset: true }));
      loadMoreBtn.addEventListener('click', () => loadTradesPage({ reset: false }));
      backfillBtn.addEventListener('click', async () => {
        backfillBtn.disabled = true;
        try {
          // Backfill for selected address or all if none selected
          if (selectedAddress) {
            await fetch('/api/backfill', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ address: selectedAddress }) });
          } else {
            const doAll = confirm('Backfill all addresses (will cleanup invalid trades first)?');
            if (doAll) {
              await fetch('/api/cleanup-and-backfill', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ limit: 100 }) });
            }
          }
          await loadTradesPage({ reset: true });
        } catch (e) { /* ignore */ } finally { backfillBtn.disabled = false; }
      });
      // No separate cleanup-all button; Backfill does per-address or global backfill
      timeModeSel.addEventListener('change', () => {
        timeMode = timeModeSel.value === 'relative' ? 'relative' : 'absolute';
        renderTrades(tradesState.items);
      });
      addrFilterSel.addEventListener('change', () => {
        selectedAddress = addrFilterSel.value;
        loadTradesPage({ reset: true });
      });
      async function populateAddressFilter() {
        try {
          const r = await fetch('/api/addresses');
          const j = await r.json();
          const addresses = j.addresses || [];
          nickMap = j.nicknames || {};
          addrFilterSel.innerHTML = '<option value="">All</option>';
          addresses.forEach(a => {
            const opt = document.createElement('option');
            const label = nickMap[a] ? `${nickMap[a]} (${a.slice(0,6)}...${a.slice(-4)})` : a;
            opt.value = a; opt.textContent = label;
            addrFilterSel.appendChild(opt);
          });
        } catch (e) {}
      }
      populateAddressFilter();
      // Ensure UI reflects default time mode on load
      if (timeModeSel) timeModeSel.value = timeMode;
      loadTradesPage({ reset: true });

      function formatUsd(n) {
        if (typeof n !== 'number' || !isFinite(n)) return '-';
        try {
          return '$' + n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        } catch { return '$' + n.toFixed(2); }
      }
      function formatTime(iso) {
        const d = new Date(iso);
        if (timeMode === 'relative') {
          const diffMs = Date.now() - d.getTime();
          const sec = Math.round(diffMs / 1000);
          const min = Math.round(sec / 60);
          const hr = Math.round(min / 60);
          const day = Math.round(hr / 24);
          if (sec < 60) return `${sec}s ago`;
          if (min < 60) return `${min}m ago`;
          if (hr < 24) return `${hr}h ago`;
          return `${day}d ago`;
        }
        return d.toLocaleString();
      }
      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, function(c){
          switch (c) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            default: return '&#39;';
          }
        });
      }
    </script>
  </body>
  </html>
