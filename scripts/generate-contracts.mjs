import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const root = path.resolve(__dirname, '..');
const schemaDir = path.join(root, 'contracts', 'jsonschema');
const tsOutFile = path.join(root, 'contracts', 'ts', 'index.ts');
const tsLibOutFile = path.join(root, 'packages', 'ts-lib', 'src', 'contracts.generated.ts');
const jsOutFile = path.join(root, 'contracts', 'ts', 'index.js');
const pyOutFile = path.join(root, 'contracts', 'py', 'models.py');

async function readSchemas() {
  const entries = await fs.readdir(schemaDir);
  const schemas = [];
  for (const file of entries.filter((f) => f.endsWith('.json')).sort()) {
    const full = path.join(schemaDir, file);
    const raw = await fs.readFile(full, 'utf8');
    const schema = JSON.parse(raw);
    schemas.push({ file, schema });
  }
  return schemas;
}

function toPascal(name) {
  return name
    .replace(/[^a-z0-9]+/gi, ' ')
    .split(' ')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function literal(value) {
  if (typeof value === 'string') return JSON.stringify(value);
  return JSON.stringify(value, null, 2);
}

function wrapNullable(expr, schema) {
  if (Array.isArray(schema.type) && schema.type.includes('null')) {
    return `z.union([${expr}, z.null()])`;
  }
  return expr;
}

function buildStringSchema(schema) {
  if (schema.enum) {
    return `z.enum([${schema.enum.map((v) => JSON.stringify(v)).join(', ')}])`;
  }
  let expr = 'z.string()';
  if (schema.format === 'date-time') expr += '.datetime()';
  if (typeof schema.minLength === 'number') expr += `.min(${schema.minLength})`;
  if (typeof schema.maxLength === 'number') expr += `.max(${schema.maxLength})`;
  if (schema.pattern) expr += `.regex(new RegExp(${JSON.stringify(schema.pattern)}))`;
  return expr;
}

function buildNumberSchema(schema, kind = 'number') {
  let expr = kind === 'integer' ? 'z.number().int()' : 'z.number()';
  if (typeof schema.minimum === 'number') expr += `.min(${schema.minimum})`;
  if (typeof schema.maximum === 'number') expr += `.max(${schema.maximum})`;
  if (typeof schema.exclusiveMinimum === 'number') expr += `.gt(${schema.exclusiveMinimum})`;
  if (typeof schema.exclusiveMaximum === 'number') expr += `.lt(${schema.exclusiveMaximum})`;
  return expr;
}

function buildArraySchema(schema) {
  const itemSchema = schema.items ? toZod(schema.items) : 'z.any()';
  let expr = `z.array(${itemSchema})`;
  if (typeof schema.minItems === 'number') expr += `.min(${schema.minItems})`;
  if (typeof schema.maxItems === 'number') expr += `.max(${schema.maxItems})`;
  return expr;
}

function buildObjectSchema(schema) {
  const props = schema.properties || {};
  const required = new Set(schema.required || []);
  const entries = Object.entries(props).map(([key, value]) => {
    let propExpr = toZod(value);
    if (!required.has(key)) propExpr += '.optional()';
    if (Object.prototype.hasOwnProperty.call(value, 'default')) {
      propExpr += `.default(${literal(value.default)})`;
    }
    return `  ${JSON.stringify(key)}: ${propExpr}`;
  });
  let expr = `z.object({\n${entries.join(',\n')}\n})`;
  if (schema.additionalProperties === false) expr += '.strict()';
  else if (schema.additionalProperties === true) expr += '.catchall(z.any())';
  return expr;
}

function toZod(schema) {
  if (!schema) return 'z.any()';
  if (schema.enum && (!schema.type || schema.type === 'string')) {
    return wrapNullable(buildStringSchema(schema), schema);
  }
  if (schema.type === 'string') return wrapNullable(buildStringSchema(schema), schema);
  if (schema.type === 'number') return wrapNullable(buildNumberSchema(schema), schema);
  if (schema.type === 'integer') return wrapNullable(buildNumberSchema(schema, 'integer'), schema);
  if (schema.type === 'boolean') return wrapNullable('z.boolean()', schema);
  if (schema.type === 'array') return wrapNullable(buildArraySchema(schema), schema);
  if (schema.type === 'object' || schema.properties || schema.additionalProperties) {
    const expr = buildObjectSchema(schema);
    return wrapNullable(expr, schema);
  }
  if (Array.isArray(schema.type)) {
    const withoutNull = schema.type.filter((t) => t !== 'null');
    if (withoutNull.length === 1) {
      return wrapNullable(toZod({ ...schema, type: withoutNull[0] }), schema);
    }
  }
  return 'z.any()';
}

function generateTs(schemas) {
  const blocks = [
    '/* eslint-disable */',
    '// Auto-generated by scripts/generate-contracts.mjs - DO NOT EDIT',
    "import { z } from 'zod';",
    ''
  ];
  const registryEntries = [];
  for (const { schema } of schemas) {
    const name = schema.title ? schema.title : toPascal(schema.$id || 'Schema');
    const constName = `${name}Schema`;
    const expr = buildObjectSchema(schema);
    blocks.push(`export const ${constName} = ${expr};`);
    blocks.push(`export type ${name} = z.infer<typeof ${constName}>;`, '');
    registryEntries.push(`  ${JSON.stringify(schema.$id || name)}: ${constName}`);
  }
  blocks.push('export const MessageSchemas = {', registryEntries.join(',\n'), '} as const;');
  return blocks.join('\n');
}

function pythonType(schema) {
  const result = {
    type: 'Any',
    nullable: false,
    factory: null,
    defaultValue: null,
    needsDatetime: false
  };
  if (!schema) return result;
  const types = Array.isArray(schema.type) ? schema.type : [schema.type || null];
  result.nullable = types.includes('null');
  const primary = types.find((t) => t && t !== 'null') || schema.type;

  if (schema.enum && (!primary || primary === 'string')) {
    result.type = `Literal[${schema.enum.map((v) => JSON.stringify(v)).join(', ')}]`;
    return result;
  }
  if (primary === 'string') {
    if (schema.format === 'date-time') {
      result.type = 'datetime';
      result.needsDatetime = true;
    } else {
      result.type = 'str';
    }
    return result;
  }
  if (primary === 'number') {
    result.type = 'float';
    return result;
  }
  if (primary === 'integer') {
    result.type = 'int';
    return result;
  }
  if (primary === 'boolean') {
    result.type = 'bool';
    return result;
  }
  if (primary === 'array') {
    const child = pythonType(schema.items);
    result.type = `list[${child.type}]`;
    result.factory = 'list';
    result.needsDatetime = result.needsDatetime || child.needsDatetime;
    return result;
  }
  if (primary === 'object' || schema.properties || schema.additionalProperties) {
    result.type = 'dict[str, Any]';
    result.factory = 'dict';
    return result;
  }
  return result;
}

function buildPythonField(schema, required) {
  const meta = pythonType(schema);
  let typeStr = meta.type;
  const optional = meta.nullable || !required;
  if (optional) {
    typeStr = `Optional[${typeStr}]`;
  }
  let defaultStr = '';
  const hasDefault = Object.prototype.hasOwnProperty.call(schema || {}, 'default');
  if (hasDefault) {
    const value = schema.default;
    if (Array.isArray(value)) {
      defaultStr = ' = Field(default_factory=list)';
    } else if (value && typeof value === 'object') {
      defaultStr = ' = Field(default_factory=dict)';
    } else {
      defaultStr = ` = ${JSON.stringify(value)}`;
    }
  } else if (!required || meta.nullable) {
    defaultStr = ' = None';
  } else if (meta.factory === 'dict') {
    defaultStr = ' = Field(default_factory=dict)';
  } else if (meta.factory === 'list') {
    defaultStr = ' = Field(default_factory=list)';
  }
  return { annotation: typeStr, defaultStr };
}

function collectPythonImports(schemas) {
  const typing = new Set();
  let needDatetime = false;
  for (const { schema } of schemas) {
    const props = schema.properties || {};
    const required = new Set(schema.required || []);
    for (const [key, prop] of Object.entries(props)) {
      const meta = pythonType(prop);
      if (meta.type.includes('Literal')) typing.add('Literal');
      if (meta.type.includes('Any')) typing.add('Any');
      if (meta.nullable || !required.has(key)) typing.add('Optional');
      if (meta.needsDatetime) needDatetime = true;
    }
  }
  return { typing, needDatetime };
}

function generatePy(schemas) {
  const header = [
    '# Auto-generated by scripts/generate-contracts.mjs - DO NOT EDIT',
    'from __future__ import annotations',
    ''
  ];
  const { typing, needDatetime } = collectPythonImports(schemas);
  if (needDatetime) header.push('from datetime import datetime');
  if (typing.size) header.push(`from typing import ${Array.from(typing).sort().join(', ')}`);
  header.push('from pydantic import BaseModel, Field', '');
  const body = [];
  for (const { schema } of schemas) {
    const name = schema.title ? schema.title : toPascal(schema.$id || 'Schema');
    body.push(`class ${name}(BaseModel):`);
    const props = schema.properties || {};
    if (!Object.keys(props).length) {
      body.push('    pass', '');
      continue;
    }
    const required = new Set(schema.required || []);
    for (const [key, prop] of Object.entries(props)) {
      const { annotation, defaultStr } = buildPythonField(prop, required.has(key));
      body.push(`    ${key}: ${annotation}${defaultStr}`);
    }
    body.push('');
  }
  return [...header, ...body].join('\n').trimEnd() + '\n';
}

function generateJs(schemas) {
  const blocks = [
    '// Auto-generated by scripts/generate-contracts.mjs - DO NOT EDIT',
    '"use strict";',
    "const { z } = require('zod');",
    ''
  ];
  const registryEntries = [];
  for (const { schema } of schemas) {
    const name = schema.title ? schema.title : toPascal(schema.$id || 'Schema');
    const constName = `${name}Schema`;
    const expr = buildObjectSchema(schema);
    blocks.push(`const ${constName} = ${expr};`);
    blocks.push(`exports.${constName} = ${constName};`, '');
    registryEntries.push(`  ${JSON.stringify(schema.$id || name)}: ${constName}`);
  }
  blocks.push('exports.MessageSchemas = {', registryEntries.join(',\n'), '};');
  return blocks.join('\n');
}

async function main() {
  const schemas = await readSchemas();
  if (!schemas.length) throw new Error('No schemas found under contracts/jsonschema');
  // Ensure dirs
  await fs.mkdir(path.dirname(tsOutFile), { recursive: true });
  await fs.mkdir(path.dirname(pyOutFile), { recursive: true });
  const ts = generateTs(schemas);
  await fs.writeFile(tsOutFile, ts);
  await fs.writeFile(tsLibOutFile, ts);
  const js = generateJs(schemas);
  await fs.writeFile(jsOutFile, js);
  const py = generatePy(schemas);
  await fs.writeFile(pyOutFile, py);
  console.log(`[contracts] generated ${schemas.length} schemas`);
}

main().catch((err) => {
  console.error('[contracts] generation failed', err);
  process.exitCode = 1;
});
